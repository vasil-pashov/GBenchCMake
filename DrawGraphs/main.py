from collections import OrderedDict
import json
import os
import argparse
import glob
import datetime
import jinja2
import pathlib
from plot import makePlotColumnDesc, DataTable, Plot, PlotDescription 

def dirPath(string):
	"""Used by argparse for directory type
	:param string: String which will be examined
	"""
	if os.path.isdir(string):
		return string
	else:
		raise NotADirectoryError(string)

class NotAFileException(Exception):
	pass

def setupArgparse():
	"""Set up command line arguments and parse them
	:returns: Parsed command line arguments
	"""
	parser=argparse.ArgumentParser()
	parser.add_argument('src', help='Directory containing perfs to be ploted.')
	parser.add_argument('dest_file', help='Destination where to put the plots from src_dir')
	parser.add_argument(
		"--type",
		choices=["bar", "plot"],
		default="plot",
		help="Type of the graph which is going to be generated."\
		 "If bar is selected a path to specific file must be given"\
		 "If plot is selected a path to folder must be given and all benchmarks will be added to the plot")
	args = parser.parse_args()
	if args.type == "plot":
		if not os.path.isdir(args.src):
			raise NotADirectoryError(args.src)
	elif args.type == "bar":
		if not os.path.isfile(args.src):
			raise NotAFileException(args.src)
	return args

def makeOptions(title: str, unit: str) -> dict:
	"""Create default options for a plot
	:param title: The title which will be shown in the UI
	:param unit: The unit along the y-axis.
	:returns: Dict with google chart compatible options ready to be dumped as json
	"""
	options = {}
	options['title'] = title
	options['legend'] = {'position': 'top'}
	options['curveType'] = 'function'
	hAxis = {
		'format': 'yyyy-M-dd',
		'gridlines': {'count': 0},
		'title': 'Date'
	}
	vAxis = {
		'title': "Execution Time ({})".format(unit),
		'minValue': 0
	}
	options['hAxis'] = hAxis
	options['vAxis'] = vAxis
	return options


def _parsePlotName(plotName: str) -> (str, str):
	"""Parse a given name to extract the fixture name and the specific name
	:param plotName: Name to be parsed
	:type plotName: str
	:returns: Tuple where the first element is the fixture name and the second element is
	the specific name. If the plot did not come from fixture second will be None
	"""

	separatorIndex=plotName.find("/")
	if separatorIndex == -1:
		return (plotName, None)
	else:
		return (plotName[:separatorIndex], plotName[separatorIndex+1:])	


def gatherPlotData(dir):
	"""Read all json files generated by run_tests.py and create plot class for each """

	allPlots={}
	pattern=os.path.join(dir, "*.json")
	fileNameList=glob.glob(pattern)
	for fileName in fileNameList:
		with open(fileName, "r") as file:
			jsonData = json.load(file)
			date = datetime.datetime.strptime(jsonData['info']['date'], "%Y/%m/%d %H:%M:%S")
			for benchmarkTask in jsonData['benchmark_list']:
				benchmarks = benchmarkTask['benchmarks']
				for benchmark in benchmarks:
					agregate=benchmark.get('aggregate_name', None)
					if agregate and agregate != "mean": 
						continue
					fullName = benchmark['run_name']
					(plotName, yValueName) =_parsePlotName(fullName)
					realTime = benchmark['real_time']
					colId = yValueName if yValueName else plotName
					row={colId: realTime}
					if plotName not in allPlots:
						columns = [
							makePlotColumnDesc("date", label="Date", type="date"),
							makePlotColumnDesc(colId, type="number")
						]
						plotDesc = PlotDescription("date", columns)
						plot = Plot(plotDesc)
						plot[date] = row
						allPlots[plotName] = plot
						plot.options = makeOptions(plotName, "")
					else:
						plot = allPlots[plotName]
						if colId not in plot.columns:
							plot.addColumn(makePlotColumnDesc(colId, type="number"))
						plot.addValue(date, row)
	return allPlots



class UnknownFormatException(Exception):
	pass


def _iterateGBenchmarks(benchmarks, allCharts):
	for benchmark in benchmarks:	
		(fixtureName, barChartName) = _parsePlotName(benchmark["run_name"])
		if benchmark.get("aggregate_name") and benchmark["agregate_name"] != "mean":
			continue
		if barChartName is not None:
			row = {"name": barChartName, "time": benchmark['real_time']}
			if fixtureName in allCharts:
				barChart = allCharts[fixtureName]
				barChart.addRow(row)
			else:
				cols = [makePlotColumnDesc("name"), makePlotColumnDesc("time", label="Execution Time", type="number")]
				barChart = DataTable(PlotDescription("name", cols))
				barChart.addRow(row)
				options = {
					"sortColumn": 0,
					"sortAscending": False,
					"sort": 'enable'
				}
				barChart.options = options
				allCharts[fixtureName] = barChart	


def gatherBarChartData(src: str) -> dict:
	allCharts = {}
	with open(src, "r") as file:
		data = json.load(file)
		if 'info' in data:
			generator = data['info'].get('generator')
			if generator is None:
				raise UnknownFormatException("Unknown generator {}".format(generator))
			for benchmarkTask in data['benchmark_list']:
				_iterateGBenchmarks(benchmarkTask['benchmarks'], allCharts)
		else:
			_iterateGBenchmarks(data['benchmarks'], allCharts)
	return allCharts


def drawPlots(plots, dest, type):
	templateLoader=jinja2.FileSystemLoader(
		os.path.join(
			pathlib.Path(__file__).parent.absolute(),
			"./templates"
		)
	)
	environment=jinja2.Environment(loader=templateLoader)
	template=environment.get_template("plot.html")
	chartConstrStr="LineChart" if type == "plot" else "ColumnChart"
	renderResult=template.render(plots=plots, chart=chartConstrStr)
	with open(dest, "w") as destFile:
		destFile.write(renderResult)

def main():
	args=setupArgparse()
	if args.type == "plot":
		plots = gatherPlotData(args.src)
		drawPlots(plots, args.dest_file, args.type)
	elif args.type == "bar":
		plots = gatherBarChartData(args.src)
		drawPlots(plots, args.dest_file, args.type)

if __name__ == '__main__':
	main()
